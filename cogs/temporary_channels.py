import discord
from discord.ext import commands
import json
import os
import threading
import importlib
import jsonschema
import shutil
import bisect

class TemporaryChannels(commands.Cog):
    def __init__(self, bot, log):
        self.bot = bot
        self.log = log

        self._room_number_lock = threading.Lock()
        self._highest_room_number = 0
        self._freed_room_numbers = []
        self._channel_room_number = {}

        if not os.path.exists('cache'):
            os.mkdir('cache')
        if not os.path.exists('config'):
            os.mkdir('config')

        self.TEMPORARY_CHANNELS_FILE = 'cache/temporary_channels.cache'
        self.CONFIG_FILE = 'config/temporary_channels.json'

        # if the config file doesn't exists copy the default one
        if not os.path.isfile(self.CONFIG_FILE):
            with importlib.resources.path('cogs.resources', 'temporary_channels_config_default.json') as default_cfg_path:
                shutil.copy2(default_cfg_path, self.CONFIG_FILE)
        
        # load and validate the config
        self._config = None
        try:
            with importlib.resources.path('cogs.resources', 'temporary_channels_config_schema.json') as schema_path:
                with open(self.CONFIG_FILE, 'r') as cfg_file, open(schema_path, 'r') as schema_file:
                    schema = json.load(schema_file)
                    self._config = json.load(cfg_file)
                    jsonschema.validate(self._config, schema)

        except Exception as e:
            err = 'Can\'t parse \'{}\': {}'.format(self.CONFIG_FILE, str(e))
            self.log.error(err)
            self._config = None

        self._temporary_channels = self.TemporaryChannelsList(self.TEMPORARY_CHANNELS_FILE, log)


    @commands.Cog.listener()
    async def on_ready(self):
        with self._temporary_channels.lock:
            for channelID in self._temporary_channels.get_list():                
                try:
                    channel = await self.bot.fetch_channel(channelID)
                    await channel.delete()
                    self._temporary_channels.remove_channel(channelID)
                except Exception:
                    pass
    
    @commands.Cog.listener()
    async def on_voice_state_update(self, member, before, after):
        if not self._config:
            return

        with self._temporary_channels.lock:
            # if the channel the user was in is a temporary channel
            # and now it's empty delete it
            if before.channel and before.channel.id in self._temporary_channels.get_list():
                try:
                    members = (await self.bot.fetch_channel(before.channel.id)).members
                    if len(members) == 0:
                        await before.channel.delete()
                        self._temporary_channels.remove_channel(before.channel.id)
                        self._free_room_number(before.channel.id)
                except Exception:
                    pass

            # ignore events generated by regular channels
            if not after.channel or after.channel.id not in [i['generatorChannelID'] for i in self._config]:
                return

            creator_channel_definition = [i for i in self._config if i['generatorChannelID'] == after.channel.id][0]

            # create a channel
            guild = after.channel.guild
            new_channel_name = None
            room_number = self._next_room_number()
            try:
                new_channel_name = creator_channel_definition['newChannelNameTemplate'].format_map({'room_number': room_number})
            except:
                new_channel_name = creator_channel_definition['newChannelNameTemplate']

            try:
                new_channel = await guild.create_voice_channel(
                    name=new_channel_name,
                    category=after.channel.category,
                    
                    # if specified in the config set the user_limit parameter
                    **({'user_limit': creator_channel_definition['userLimit']} if 'userLimit' in creator_channel_definition else {})
                )
                self._channel_room_number[new_channel.id] = room_number
            except Exception as e:
                self.log.error('Can\'t create temporary channel \'{}\': {}', new_channel_name, str(e))
                self._free_room_number(room_number)
                return
            
            self._channel_room_number[new_channel.id] = room_number
            self._temporary_channels.add_channel(new_channel.id)
            await member.move_to(new_channel)
    
    def _next_room_number(self):
        with self._room_number_lock:
            if len(self._freed_room_numbers) == 0:
                self._highest_room_number += 1
                return self._highest_room_number
            else:
                least = self._freed_room_numbers.pop(0)
                return least

    def _free_room_number(self, channel_id):
        with self._room_number_lock:
            bisect.insort(self._freed_room_numbers, self._channel_room_number[channel_id])
            del self._channel_room_number[channel_id]

    # class that manages cuncurrent access to the cache file
    class TemporaryChannelsList:
        def __init__(self, filePath, log):
            self.filePath = filePath
            self.log = log

            self.lock = threading.RLock()
            self._channels = []

            self._load()

        def _load(self):
            try:
                with open(self.filePath, 'r') as f, self.lock:
                    self._channels = json.load(f)
            except Exception as e:
                self.log.warning('Can\'t parse \'{}\': {}'.format(self.filePath, str(e)))
                self._channels = []

        def _save(self):
            try:
                with open(self.filePath, 'w') as f, self.lock:
                    json.dump(self._channels, f)
            except Exception as e:
                self.log.warning('Can\'t dump temporary channels in \'{}\': {}'.format(self.filePath, str(e)))
        
        def get_list(self):
            return self._channels.copy()
        
        def add_channel(self, channelID):
            self._channels.append(channelID)
            self._save()

        def remove_channel(self, channelID):
            self._channels.remove(channelID)
            self._save()