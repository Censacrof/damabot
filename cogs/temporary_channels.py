import discord
from discord.ext import commands
import json
import os
import threading
import importlib
import jsonschema
import shutil

class TemporaryChannels(commands.Cog):
    def __init__(self, bot, log):
        self.bot = bot
        self.log = log

        if not os.path.exists('cache'):
            os.mkdir('cache')

        self.TEMPORARY_CHANNELS_FILE = 'cache/temporary_channels.cache'
        self.CONFIG_FILE = 'temporary_channels_config.json'

        # if the config file doesn't exists copy the default one
        if not os.path.isfile(self.CONFIG_FILE):
            with importlib.resources.path('cogs.resources', 'temporary_channels_config_default.json') as default_cfg_path:
                shutil.copy2(default_cfg_path, self.CONFIG_FILE)
        
        # load and validate the config
        self._config = None
        try:
            with importlib.resources.path('cogs.resources', 'temporary_channels_config_schema.json') as schema_path:
                with open(self.CONFIG_FILE, 'r') as cfg_file, open(schema_path, 'r') as schema_file:
                    schema = json.load(schema_file)
                    self._config = json.load(cfg_file)
                    jsonschema.validate(self._config, schema)

        except Exception as e:
            err = 'Can\'t parse \'{}\': {}'.format(self.CONFIG_FILE, str(e))
            self.log.error(err)
            self._config = None

        self._temporary_channels = self.TemporaryChannelsList(self.TEMPORARY_CHANNELS_FILE, log)


    @commands.Cog.listener()
    async def on_ready(self):
        with self._temporary_channels.lock:
            for channelID in self._temporary_channels.get_list():
                channel = await self.bot.fetch_channel(channelID)
                try:
                    await channel.delete()
                    self._temporary_channels.remove_channel(channelID)
                except Exception:
                    pass
    
    @commands.Cog.listener()
    async def on_voice_state_update(self, member, before, after):
        if not self._config:
            return

        with self._temporary_channels.lock:
            # if the channel the user was in is a temporary channel
            # and now it's empty delete it
            if before.channel and before.channel.id in self._temporary_channels.get_list():
                try:
                    members = (await self.bot.fetch_channel(before.channel.id)).members
                    if len(members) == 0:
                        await before.channel.delete()
                        self._temporary_channels.remove_channel(before.channel.id)
                except Exception:
                    pass

            # ignore events generated by regular channels
            if not after.channel or after.channel.id not in [i['generatorChannelID'] for i in self._config]:
                return

            creator_channel_definition = [i for i in self._config if i['generatorChannelID'] == after.channel.id][0]

            # create a channel
            guild = after.channel.guild
            new_channel_name = None
            try:
                new_channel_name = creator_channel_definition['newChannelNameTemplate'].format_map({'count': 1})
            except:
                new_channel_name = creator_channel_definition['newChannelNameTemplate']

            new_channel = await guild.create_voice_channel(
                name=new_channel_name,
                category=after.channel.category,
                
                # if specified in the config set the user_limit parameter
                **({'user_limit': creator_channel_definition['userLimit']} if 'userLimit' in creator_channel_definition else {})
            )
            self._temporary_channels.add_channel(new_channel.id)
            await member.move_to(new_channel)
    
    # class that manages cuncurrent access to the cache file
    class TemporaryChannelsList:
        def __init__(self, filePath, log):
            self.filePath = filePath
            self.log = log

            self.lock = threading.RLock()
            self._channels = []

            self._load()

        def _load(self):
            try:
                with open(self.filePath, 'r') as f, self.lock:
                    self._channels = json.load(f)
            except Exception as e:
                self.log.warning('Can\'t parse \'{}\': {}'.format(self.filePath, str(e)))
                self._channels = []

        def _save(self):
            try:
                with open(self.filePath, 'w') as f, self.lock:
                    json.dump(self._channels, f)
            except Exception as e:
                self.log.warning('Can\'t dump temporary channels in \'{}\': {}'.format(self.filePath, str(e)))
        
        def get_list(self):
            return self._channels.copy()
        
        def add_channel(self, channelID):
            self._channels.append(channelID)
            self._save()

        def remove_channel(self, channelID):
            self._channels.remove(channelID)
            self._save()